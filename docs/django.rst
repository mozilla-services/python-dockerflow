Django
======

The package ``dockerflow.django`` package implements various tools to support
Django projects that want to follow the Dockerflow specs:

- A Python logging formatter following the `mozlog`_ format to be used in
  the ``LOGGING`` setting.

- Views for health monitoring:

  - ``/__version__`` - Serves a ``version.json`` file

  - ``/__heartbeat__`` - Run Django checks as configured
    in the ``DOCKERFLOW_CHECKS`` setting

  - ``/__lbheartbeat__`` - Retuns a HTTP 200 response

- A middleware to emit `request.summary`_ log records based on request specific
  data, and to serve the health monitoring views.

- Signals for passed and failed heartbeats.

.. _`mozlog`: https://github.com/mozilla-services/Dockerflow/blob/main/docs/mozlog.md
.. _`request.summary`: https://github.com/mozilla-services/Dockerflow/blob/main/docs/mozlog.md#application-request-summary-type-requestsummary

.. seealso::

    For more information see the :doc:`API documentation <api/django>` for
    the ``dockerflow.django`` module.

Setup
-----

To install ``python-dockerflow``'s Django support please follow these steps:

#. Add ``dockerflow.django`` to your ``INSTALLED_APPS`` setting

#. Define a ``BASE_DIR`` setting that is the root path of your Django project.
   This will be used to locate the ``version.json`` file that is generated by
   CircleCI or another process during deployment.

   .. seealso:: :ref:`django-versions` for more information

#. Add the ``DockerflowMiddleware`` to your ``MIDDLEWARE`` setting::

    MIDDLEWARE = [
        # ...
        # 'django.middleware.security.SecurityMiddleware',
        'dockerflow.django.middleware.DockerflowMiddleware',
        # ...
    ]

#. (Optional) Add the healthcheck views to SECURE_REDIRECT_EXEMPT_, so they can
   be used as `Kubernetes liveness checks`_::

    SECURE_REDIRECT_EXEMPT = [
        r"^__version__/?$",
        r"^__heartbeat__/?$",
        r"^__lbheartbeat__/?$",
    ]

#. :ref:`Configure logging <django-logging>` to use the
   :class:`~dockerflow.logging.MozlogHandler`
   logging handler for the ``request.summary`` logger (you may have to
   extend your existing logging configuration!).

.. _`Kubernetes liveness checks`: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
.. _SECURE_REDIRECT_EXEMPT: https://docs.djangoproject.com/en/stable/ref/settings/#secure-redirect-exempt

.. _django-config:

Configuration
-------------

.. epigraph::

   Accept its configuration through environment variables.

There are several options to handle configuration values through
environment variables, e.g. as shown in the `configuration grid`_ on
djangopackages.com.

``os.environ``
~~~~~~~~~~~~~~

The simplest is to use Python's ``os.environ`` object to access
environment variables for settings and other variables, e.g.::

    MY_SETTING = os.environ.get('DJANGO_MY_SETTING', 'default value')

The downside of that is that it nicely works only for string
based variables, since that's what ``os.environ`` returns.

python-decouple
~~~~~~~~~~~~~~~

A good replacement is python-decouple_ as it's agnostic to the
framework in use and offers casting the returned value to the type
wanted, e.g.::

    from decouple import config

    MY_SETTING = config('DJANGO_MY_SETTING', default='default value')
    DEBUG = config('DJANGO_DEBUG', default=False, cast=bool)

As you can see the ``DEBUG`` setting would be populated from the
``DJANGO_DEBUG`` environment variable but also be cast as a boolean
(while considering the string values ``'1'``, ``'yes'``, ``'true'`` and
``'on'`` as truthy values, and similar for falsey values).

django-environ
~~~~~~~~~~~~~~

Django-environ_ follows similar patterns as python-decouple but implements
specific casters for typical Django settings. E.g.::

    import environ
    env = environ.Env()

    MY_SETTING = env.str('DJANGO_MY_SETTING', default='default value')
    DEBUG = env.bool('DJANGO_DEBUG', default=False)
    DATABASES = {
        'default': env.db(),  # automatically looks for DATABASE_URL
    }

django-configurations
~~~~~~~~~~~~~~~~~~~~~

If you're interested in even more complex scenarios there are
tools like django-configurations_ which allows loading different sets
of settings depending on an additional environment variable
``DJANGO_CONFIGURATION`` to separate settings by environment
(e.g. dev, stage, prod). It also ships with ``Value`` classes that
implement configuration parsing from environment variable and casting,
e.g.::

    from configurations import Configuration, values

    class Dev(Configuration):
        SESSION_COOKIE_SECURE = False
        DEBUG = values.BooleanValue(default=False)

    class Prod(Dev):
        SESSION_COOKIE_SECURE = True

In that example the configuration class that is given in the
``DJANGO_CONFIGURATION`` environment variable would be used as the base
for Django's settings.

.. _configuration grid: https://djangopackages.org/grids/g/configuration/
.. _python-decouple: https://pypi.python.org/pypi/python-decouple
.. _Django-environ: https://django-environ.readthedocs.io/
.. _Django-configurations: https://django-configurations.readthedocs.io/

.. _django-serving:

``PORT``
--------

.. epigraph::

   Listen on environment variable ``$PORT`` for HTTP requests.

Depending on which WSGI server you are using to run your Python application
there are different ways to accept the :envvar:`PORT` as the port to launch
your application with.

It's recommended to use port ``8000`` by default.

Gunicorn
~~~~~~~~

Gunicorn automatically will bind to the hostname:port combination of
``0.0.0.0:$PORT`` if it find the :envvar:`PORT` environment variable.
That means running gunicorn is as simple as using this::

    gunicorn myproject.wsgi:application --workers 4 --access-logfile -

.. seealso::

    The `full gunicorn documentation <http://docs.gunicorn.org/>`_
    for more details.

uWSGI
~~~~~

For uWSGI all you have to do is to bind on the :envvar:`PORT` when you
define the ``uwsgi.ini``, e.g.:

.. code-block:: ini

    [uwsgi]
    http-socket = :$(PORT)
    master = true
    processes = 4
    module = myproject.wsgi:application
    chdir = /app
    enable-threads = True

.. seealso::

    The `full uWSGI documentation <http://uwsgi-docs.readthedocs.io/>`_
    for more details.

.. _django-versions:

Versions
--------

.. epigraph::

   Must have a JSON version object at /app/version.json.

Dockerflow requires writing a `version object`_ to the file ``/app/version.json``
as seen from the docker container to be served under the URL path
``/__version__``.

To facilitate this python-dockerflow contains a Django view to read the
file under path ``BASE_DIR + 'version.json'`` where
``BASE_DIR`` is required to be defined in the Django project settings, e.g.:

.. code-block:: python

    import os
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

Assuming that the ``settings.py`` file is contained in the project folder
That means the ``BASE_DIR`` setting will be the one where the ``manage.py``
file is located in the below example directory tree:

.. code-block:: text
   :emphasize-lines: 14,22

    .
    ├── .dockerignore
    ├── .gitignore
    ├── Dockerfile
    ├── README.rst
    ├── circle.yml
    ├── manage.py
    ├── requirements.txt
    ├── staticfiles
    │   └── ..
    ├── tests
    │   └── ..
    ├── version.json
    ├── myproject
    │   ├── app1
    │   │   ├── ..
    │   │   └── ..
    │   ├── app2
    │   │   ├── ..
    │   │   └── ..
    │   ├── settings.py
    │   └── urls.py
    └── ..

.. _version object: https://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md

.. _django-health:

Health monitoring
-----------------

Health monitoring happens via three different views following the Dockerflow_
spec:

.. _http_get_version:
.. http:get:: /__version__

   The view that serves the :ref:`version information <django-versions>`.

   **Example request**:

   .. sourcecode:: http

      GET /__version__ HTTP/1.1
      Host: example.com

   **Example response**:

   .. sourcecode:: http

      HTTP/1.1 200 OK
      Vary: Accept-Encoding
      Content-Type: application/json

      {
        "commit": "52ce614fbf99540a1bf6228e36be6cef63b4d73b",
        "version": "2017.11.0",
        "source": "https://github.com/mozilla/telemetry-analysis-service",
        "build": "https://circleci.com/gh/mozilla/telemetry-analysis-service/2223"
      }

   :statuscode 200: no error
   :statuscode 404: a version.json wasn't found

.. _http_get_heartbeat:
.. http:get:: /__heartbeat__

   The heartbeat view will go through the list of configured Dockerflow
   checks in the :ref:`DOCKERFLOW_CHECKS` setting, run each check, and, if
   ``settings.DEBUG`` is ``True``, add their results to a JSON response.

   The view will return HTTP responses with either a status code of 200 if
   all checks ran successfully or 500 if there was one or more warnings or
   errors returned by the checks.

   The check processes will log to ``dockerflow.checks.register``. Failed
   checks that cause the heartbeat to fail are logged at ``ERROR`` level
   or higher. Successful checks are logged at ``INFO`` level and higher.
   The check setup process is logged at the ``DEBUG`` level. Since failure
   details are omitted with ``DEBUG=False``, this logger should emit logs
   at ``WARNING`` or ``ERROR`` level in production, so that the logs can
   be used to diagnose heartbeat failures.

   **Custom Dockerflow checks:**

   To write your own custom Dockerflow checks, please follow the documentation
   about :mod:`Django's system check framework <django.core.checks>` and
   particularly the section **"Writing your own checks"**.

   .. note:: Don't forget to add the check additionally to the
             :ref:`DOCKERFLOW_CHECKS` setting once you've added it to your
             code.

   **Example request**:

   .. sourcecode:: http

      GET /__heartbeat__ HTTP/1.1
      Host: example.com

   **Example response, DEBUG=True**:

   .. sourcecode:: http

      HTTP/1.1 500 Internal Server Error
      Vary: Accept-Encoding
      Content-Type: application/json

      {
        "status": "warning",
        "checks": {
          "check_debug": "ok",
          "check_sts_preload": "warning"
        },
        "details": {
          "check_sts_preload": {
            "status": "warning",
            "level": 30,
            "messages": {
              "security.W021": "You have not set the SECURE_HSTS_PRELOAD setting to True. Without this, your site cannot be submitted to the browser preload list."
            }
          }
        }
      }

   **Example response, DEBUG=False**:

   .. sourcecode:: http

      HTTP/1.1 500 Internal Server Error
      Vary: Accept-Encoding
      Content-Type: application/json

      {
        "status": "warning"
      }

   :statuscode 200: no error, with potential warnings
   :statuscode 500: there was an error

   .. note:: Failed status code can be configured with the ``DOCKERFLOW_HEARTBEAT_FAILED_STATUS_CODE``
             setting (eg. 503 instead of 500)

.. http:get:: /__lbheartbeat__

   The view that simply returns a successful HTTP response so that a load
   balancer in front of the application can check that the web application
   has started up.

   **Example request**:

   .. sourcecode:: http

      GET /__lbheartbeat__ HTTP/1.1
      Host: example.com

   **Example response**:

   .. sourcecode:: http

      HTTP/1.1 200 OK
      Vary: Accept-Encoding
      Content-Type: application/json

   :statuscode 200: no error

.. _Dockerflow: https://github.com/mozilla-services/Dockerflow

.. _django-logging:

Logging
-------

Dockerflow provides a :class:`~dockerflow.logging.MozlogHandler` Python
logging handler class. This handler formats logs according to the Mozlog schema
and emits them to stdout.

To use it, put something like this in your Django ``settings`` file and
configure **at least** the ``request.summary`` logger that way::

    LOGGING = {
        'version': 1,
        'filters': {
            'request_id': {
                '()': 'dockerflow.logging.RequestIdLogFilter',
            },
        },
        'handlers': {
            'console': {
                'level': 'DEBUG',
                'class': 'dockerflow.logging.MozlogHandler',
                'filters': ['request_id']
            },
        },
        'loggers': {
            'request.summary': {
                'handlers': ['console'],
                'level': 'DEBUG',
            },
            'dockerflow': {
                'handlers': ['console'],
                'level': 'WARNING',
            },
        }
    }

In order to include querystrings in the request summary log, set
:ref:`this flag <DOCKERFLOW_SUMMARY_LOG_QUERYSTRING>` in settings:

.. code-block:: python

    DOCKERFLOW_SUMMARY_LOG_QUERYSTRING = True


MozLog App-Specific Fields
~~~~~~~~~~~~~~~~~~~~~~~~~~

The *MozLog* formatter will output ``Fields`` application-specific fields. It can be populated through the ``extra`` parameter:

.. code-block:: python

    logger.info(
        "Subsystem %s running at %s:%s",
        name, host, port,
        extra={"phase": "started", "host": host, "port": port}
    )

.. _requests_correlation_id:

Requests Correlation ID
~~~~~~~~~~~~~~~~~~~~~~~

A unique request ID is read from the ``X-Request-ID`` request header, and a UUID4 value is generated if unset.

Leveraging the ``RequestIdLogFilter`` in logging configuration as shown above will add a ``rid`` field into the ``Fields`` entry of all log messages.

The header name to obtain the request ID can be
`customized in settings <DOCKERFLOW_REQUEST_ID_HEADER_NAME>`_:

.. code-block:: python

    DOCKERFLOW_REQUEST_ID_HEADER_NAME = "X-Cloud-Trace-Context"


.. _django-static:

Static content
--------------

To properly serve static content it's recommended to use `Whitenoise`_.
It contains a middleware that is able to serve files that were built by
Django's collectstatic management command (e.g. including bundle files
built by django-pipeline) with **far-future headers** and proper response
headers for the AWS CDN to work.

To enable Whitenoise, please install it from PyPI and then enable it
in your Django projet:

#. Set your ``STATIC_ROOT`` setting::

       STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

#. Add the middleware to your ``MIDDLEWARE`` setting::

       MIDDLEWARE = [
           # 'django.middleware.security.SecurityMiddleware',
           'whitenoise.middleware.WhiteNoiseMiddleware',
           # ...
       ]

   Make sure to follow the SecurityMiddleware.

#. Enable the staticfiles_ storage that is able to compress files during
   collection and ship them with far-future headers::

       STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

.. _Whitenoise: https://whitenoise.readthedocs.io/

#. Install brotlipy_ so the storage can generate compressed files of your
   static files in the brotli_ format.

For more configuration options and details how to use Whitenoise see
the section about `Using WhiteNoise with Django`_ in its documentation.

.. _staticfiles: https://docs.djangoproject.com/en/stable/howto/static-files/
.. _brotli: https://en.wikipedia.org/wiki/Brotli
.. _brotlipy: http://brotlipy.readthedocs.org/en/latest/
.. _`Using WhiteNoise with Django`: https://whitenoise.readthedocs.io/en/stable/django.html

Settings
--------

``DEBUG``
~~~~~~~~~

The standard Django setting DEBUG_ is referenced by the
:ref:`__heartbeat__<http_get_heartbeat>` view. If it is set to ``True``, then:

- Django's deployment checks are run. These are the additional checks ran by
  including the ``--deploy`` flag, such as ``python manage.py check --deploy``.

- The ``checks`` and ``details`` objects are omitted from the JSON response,
  leaving only the ``status`` of ``ok``, ``warning`` or ``error``.

.. _DEBUG: https://docs.djangoproject.com/en/stable/ref/settings/#debug

.. _DOCKERFLOW_CHECKS:

``DOCKERFLOW_CHECKS``
~~~~~~~~~~~~~~~~~~~~~

A list of dotted import paths to register during
Django setup, to be used in the rendering of the
:ref:`__heartbeat__<http_get_heartbeat>` view.
Defaults to:

.. code-block:: python

    DOCKERFLOW_CHECKS = [
        'dockerflow.django.checks.check_database_connected',
        'dockerflow.django.checks.check_migrations_applied',
    ]

.. _DOCKERFLOW_HEARTBEAT_FAILED_STATUS_CODE:

``DOCKERFLOW_HEARTBEAT_FAILED_STATUS_CODE``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the :ref:`__heartbeat__<http_get_heartbeat>` view, this setting
is used to set the status code when a check fails at ``error`` or higher.
If unset, the default is ``500`` for an Internal Server Error.

.. _DOCKERFLOW_REQUEST_ID_HEADER_NAME:

``DOCKERFLOW_REQUEST_ID_HEADER_NAME``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The case-insenstive name of the HTTP header referenced for identifying a
request.  The default is `X-Request-ID`, used by the
`Heroku router <https://devcenter.heroku.com/articles/http-request-id#how-it-works>`_.
If the header is not set by the incoming request, a UUID is generated
for the :ref:`requests correlation ID<requests_correlation_id>`.

A good value is the header name used by your deployment infrastructure.
For example, the Google Cloud Platform sets the W3C standard ``traceparent``
header as well as a legacy ``X-Cloud-Trace-Context`` header for
`trace context <cloud.google.com/trace/docs/trace-context>`_.

.. _DOCKERFLOW_SUMMARY_LOG_QUERYSTRING:

``DOCKERFLOW_SUMMARY_LOG_QUERYSTRING``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If set to ``True``, then the request summary log will include the querystring.
This defaults to ``False``, in case there is user-sensitive information in
some querystrings.

.. _DOCKERFLOW_VERSION_CALLBACK:


``DOCKERFLOW_VERSION_CALLBACK``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The dotted import path for the callable that takes a
`HttpRequest <https://docs.djangoproject.com/en/stable/ref/request-response/#httprequest-objects>`_
and returns the :ref:`version content<django-versions>` to return under
:ref:`__version__<http_get_version>`. This defaults to ``dockerflow.version.get_version``.

``SILENCED_SYSTEM_CHECKS``
~~~~~~~~~~~~~~~~~~~~~~~~~~

The standard Django setting SILENCED_SYSTEM_CHECKS_ is used by the
:ref:`__heartbeat__<http_get_heartbeat>` view to omit the named checks.

.. _SILENCED_SYSTEM_CHECKS: https://docs.djangoproject.com/en/stable/ref/settings/#silenced-system-checks
